newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
##test function with rnorm
rnorm(10)
fun.boot(c(1,2,3,4,5,6))
rm( list = ls() )
fun.boot <- function(data=c()) {
newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
##test function with rnorm
rnorm(10)
fun.boot(c(1,2,3,4,5,6))
rm( list = ls() )
nbs=1000
fun.boot <- function(data=c()) {
newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
##test function with rnorm
rnorm(10)
sapply(1:nbs,fun.boot(c(1,2,3,4,5,6)))
sapply(1:nbs,fun.boot(c(1,2,3,4,5,6)))
sapply(1:1000,fun.boot(c(1,2,3,4,5,6)))
fun.boot(c(1,2,3,4,5,6))
fun.boot(c(1,2,3,4,5,6))
fun.boot(c(1,2,3,4,5,6))
fun.boot(c(1,2,3,4,5,6))
matrix(rep(seq(4), 4), ncol = 4)
df <- data.frame(matrix(rep(seq(4), 4), ncol = 4))
df
sapply(df,mean)
rm( list = ls() )
nbs=1000
fun.boot <- function(data=c()) {
data <- rnorm(100)
newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
##test function with rnorm
sapply(1:nbs,fun.boot())
un.boot <- function(data=c()) {
data <- rnorm(100)
newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
fun.boot <- function(data=c()) {
data <- rnorm(100)
newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
sapply(df,mean)
fun.boot <- function(data=c()) {
newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
fun.boot(c(1,2,3,4))
fun.boot(c(1,2,3,4))
fun.boot(c(1,2,3,4))
fun.boot(c(1,2,3,4))
fun.boot(c(1,2,3,4))
fun.boot(c(1,2,3,4))
fun.boot <- function(data) {
newsamp <- sample(data, replace = T)
newsamp.median <- median(newsamp)
return(newsamp.median)
}
sapply(1:100,mean)
sapply(1:100,fun.boot())
sapply(1:100,fun.boot(rnorm(10)))
sapply(1:100,fun.boot(rnorm(10)))
sapply(1:100,fun.boot(data))
sapply(1:100,fun.boot)
sapply(1:2000,median)
bsresult <- numeric(1000)
bsresult
rnorm(100)
rnorm(100)
rnorm(100,2)
rnorm(1000)
NBS=1000
fun.boot <- function(data,NBS) {
bssampe <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
df <- data.frame(bsamp,conf)
colnames(df) <- c("collection","conf")
return(df)
}
fun.boot(rnorm(1000))
NBS<-1000
fun.boot <- function(data,NBS) {
bssampe <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
df <- data.frame(bsamp,conf)
colnames(df) <- c("collection","conf")
return(df)
}
fun.boot(rnorm(1000),NBS)
NBS<-1000
fun.boot <- function(data,NBS) {
bssampe <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
df <- data.frame(bssamp,conf)
colnames(df) <- c("collection","conf")
return(df)
}
fun.boot(rnorm(1000),NBS)
NBS<-1000
fun.boot <- function(data,NBS) {
bssampe <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
df <- data.frame(bssamp,conf)
colnames(df) <- c("collection","conf")
return(df)
}
fun.boot(rnorm(1000),NBS)
NBS<-1000
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
df <- data.frame(bssamp,conf)
colnames(df) <- c("collection","conf")
return(df)
}
fun.boot(rnorm(1000),NBS)
NBS<-1000
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
fun.boot(rnorm(1000),NBS)
NBS<-1000
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
fun.boot(c(1,2,3,4,5),NBS)
NBS<-1000
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
fun.boot(c(1,2,3,4,5),NBS)
l <- fun.boot(c(1,2,3,4,5),NBS)
l
l[1]
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
l <- fun.boot(c(1,2,3,4,5),NBS)
hist(l,breaks=100,xlab="Bootstrapped Medians of rnorm dist")
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
l <- fun.boot(c(1,2,3,4,5),NBS)
hist(l[1],breaks=100,xlab="Bootstrapped Medians of rnorm dist")
l[1]
hist(l[1])
data.matrix(l[1])
hist(data.matrix(l[1]))
as.numeric(l[1])
as.numeric(unlist(l[1]))
hist(as.numeric(unlist(l[1])))
hist(as.numeric(unlist(l[1])),breaks=100,xlab="Bootstrapped Medians of rnorm dist")
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
l <- fun.boot(rnorm(100)),NBS)
hist(as.numeric(unlist(l[1])),breaks=100,xlab="Bootstrapped Medians of rnorm dist")
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
l <- fun.boot(rnorm(100)),NBS)
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
l <- fun.boot(c(1,2,3,4,5),NBS)
hist(as.numeric(unlist(l[1])),breaks=100,xlab="Bootstrapped Medians of rnorm dist")
NBS<-2000
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
l <- fun.boot(rnorm(100),NBS)
hist(as.numeric(unlist(l[1])),breaks=100,xlab="Bootstrapped Medians of rnorm dist")
NBS<-2000
fun.boot <- function(data,NBS) {
bssamp <- numeric(NBS)
#collecting iterations
for (i in 1:NBS) {
bssamp[i] <- median(sample(data, replace = T))
}
conf = quantile(bssamp,c(.025,.5,.975))
return(list(bssamp,conf))
}
l <- fun.boot(rnorm(100),NBS)
hist(as.numeric(unlist(l[1])),breaks=100,xlab="Bootstrapped Medians of rnorm dist")
bootmed = function(x, NBS) {
z = x[!is.na(x)] #missing part->out
n = length(z)    #how many obs?
bs = sapply(1:NBS, function(i)
median ( sample(z,n, replace=TRUE)) )
confint = quantile (x = bs, probs = c(.025,  .975))
return( list(conf.int = confint, mean = mean(bs) , bs=bs))
}
# Some examples
n.sample = 100
mylambda = 200
x1 = rpois(n.sample, lambda = mylambda)
b1 =bootmed(x1,1000)
print(b1$conf.int)
hist(b1$bs,breaks = 20, main  = 'from bootstrap: clearly not Normal')
#compare to CLT results
x1.median = median(x1)
x1.sd = sd(x1)
ifnormal.confint = x1.median + c(-1,+1) * 1.96*x1.sd/sqrt(n.sample)
cat(ifnormal.confint)
b1.normal = rnorm(1000, mean = median(x1), sd=x1.sd/sqrt(n.sample))
hist(b1.normal,main='if sampling dist of median was normal' , 20)
x1
?rpois
hist(X1)
hist(x1)
?beta
?gamma
rootk = function(number, k , start = NULL)
{
if ( sum(number<0) >0 )
stop("'number' has negative elements!")
if (is.null(start) )
start  = rep(1, length(number)) # starting point
# call optim
op = optim(par = start, fn = objf , number = number , k=k , method="BFGS")
# check if it is working
if ( op$convergence != 0 )
{
print(op)
print(' *********************** ')
print("convergence did not happen!")
}
r = op$par
return(   abs(r) )
}
round( rootk (1:10 , 1) , 4)
round( rootk (1:10 , 1) , 4)
round( rootk (1:10 , 1) , 4)
round( rootk (1:10 , 1) , 4)
round( rootk (1:10 , 1) , 4)
round( rootk (1:10 , 1) , 4)
round( rootk (1:10 , 1) , 4)
round( rootk (1:10 , 1) , 4)
objf = function(r, number , k)
{
# how good a candidate is r for root k of number
measure = sum( (number - r^k )^2 )
return (measure)
}
rootk = function(number, k , start = NULL)
{
if ( sum(number<0) >0 )
stop("'number' has negative elements!")
if (is.null(start) )
start  = rep(1, length(number)) # starting point
# call optim
op = optim(par = start, fn = objf , number = number , k=k , method="BFGS")
# check if it is working
if ( op$convergence != 0 )
{
print(op)
print(' *********************** ')
print("convergence did not happen!")
}
r = op$par
return(   abs(r) )
}
ls
ls
install.packages("plyr")
library("calibrate", lib.loc="~/Library/R/3.2/library")
detach("package:calibrate", unload=TRUE)
detach("package:plyr", unload=TRUE)
library(car)
library(psych)
library(gmodels)
library(MASS)
library(plyr)
dating <- read.csv("Dating.csv",header = TRUE)
setwd('/Users/ceccarelli/MIDS/DATASCI_W203/Assignments/Labs/Final Exam/')
rm( list = ls() )
dating <- read.csv("Dating.csv",header = TRUE)
#inspect life_quality variable
summary(dating$life_quality)
levels(dating$life_quality)
#wrapper function to easily recode factors
changelevels <- function(f, ...) {
f <- as.factor(f)
levels(f) <- list(...)
f
}
dating$life_quality_cleaned <- changelevels(dating$life_quality, "5"=c("1"), "4"=c("2"), "3"=c("3"),"2"=c("4"),"1"=c("5"),"NA"=c("Don't know","Refused"))
levels(dating$life_quality_cleaned)
##appears NA is a string in dating$life_quality_cleaned, recode to true NA
is.na(dating) <- dating=="NA"
# Can fix the remaining "NA" after fix by recreating the factor
dating$life_quality_cleaned <- factor(dating$life_quality_cleaned)
#check summary output
summary(dating$life_quality_cleaned)
#convert to numeric to use in regression using ali's method
dating$life_quality_cleaned <- as.numeric(as.character(dating$life_quality_cleaned))
#compute the mean for life quality to answer 15. a
mean(dating$life_quality_cleaned, na.rm =TRUE)
summary(dating$life_quality_cleaned)
hist(dating$life_quality_cleaned)
##review values for dating$years_in_relationship & age
counts_yrs = as.data.frame(table(dating$years_in_relationship))
counts_yrs[with(counts_yrs,order(-Freq)),]
counts_age = as.data.frame(table(dating$age))
counts_age[with(counts_age,order(-Freq)),]
dating$years_in_relationship_cleaned <- dating$years_in_relationship
#in this instance, use plyr instead to mapvalues
dating$years_in_relationship_cleaned <- mapvalues(dating$years_in_relationship_cleaned, from = c(" ","Refused"), to= c("NA", "NA"))
##appears NA is a string in dating$years_in_relationship_cleaned, recode to true NA
is.na(dating) <- dating=="NA"
# Can fix the remaining "NA" after fix by recreating the factor
dating$years_in_relationship_cleaned <- factor(dating$years_in_relationship_cleaned)
#recheck counts to make sure nothing amiss
counts = as.data.frame(table(dating$years_in_relationship_cleaned))
counts[with(counts,order(-Freq)),]
#check total counts, 59 NA's not included
sum(as.numeric(counts$Freq))
hist(as.numeric(dating$years_in_relationship_cleaned))
#update to be numeric following Alis Guidance
dating$years_in_relationship_cleaned <- as.numeric(as.character(dating$years_in_relationship_cleaned))
##finally, check for spurious values when years_in_relationship exceeds age
dating$years_in_relationship_cleaned.spurious <- as.numeric(as.character(dating$years_in_relationship_cleaned)) > dating$age
table(dating$years_in_relationship_cleaned.spurious)
##One value where this occurs, recode to NA
#View(data.frame(dating[dating[,"years_in_relationship_cleaned.spurious"],]))
is.na(dating$years_in_relationship_cleaned) <- dating$years_in_relationship_cleaned.spurious==TRUE
dating$years_in_relationship_cleaned <- factor(dating$years_in_relationship_cleaned)
dating$years_in_relationship_cleaned <- as.numeric(as.character(dating$years_in_relationship_cleaned))
#compute the mean for life quality to answer 15. b
mean(dating$years_in_relationship_cleaned,  na.rm =TRUE)
##check use_internet
summary(dating$use_internet)
#remap values
dating$use_internet_cleaned <- mapvalues(dating$use_internet, from = c(" ","Don't know","Refused"), to= c("NA","NA","NA"))
## NA is a string in dating$use_internet_cleaned, recode to true NA
is.na(dating) <- dating=="NA"
# Can fix the remaining "NA" after fix by recreating the factor
dating$use_internet_cleaned<- factor(dating$use_internet_cleaned)
##check use_internet again
summary(dating$use_internet_cleaned)
#compute lim_rows logical vector for the 3 variables in question
lim_rows = complete.cases(dating$life_quality_cleaned, dating$use_internet_cleaned, dating$years_in_relationship_cleaned)
## just the complete cases, count the rows with nrow to answer 15. c
dating_lim = dating[lim_rows,]
nrow(dating_lim)
lmod1 <- lm(life_quality_cleaned ~ years_in_relationship_cleaned, dating_lim)
plot(dating$life_quality_cleaned ~ dating$years_in_relationship_cleaned)
abline(lmod1)
##plot model to review
plot(lmod1)
#fit multivariate ols linear model: life_quality outcome, use_internet
#and years_in relationship as predictors
lmod2 <- lm(life_quality_cleaned ~ years_in_relationship_cleaned + use_internet_cleaned, dating_lim)
summary(lmod2)
coef(lmod2)
# compare the model improvement with anova
anova(lmod1, lmod2)
# also check the AIC
AIC(lmod1)
AIC(lmod2)
summary(dating$flirted_online)
#remap values
dating$flirted_online_cleaned <- mapvalues(dating$flirted_online, from = c(" ","Don't know","Refused"), to= c("NA","NA","NA"))
## NA is a string in dating$flirted_online_cleaned, recode to true NA
is.na(dating) <- dating=="NA"
# Can fix the remaining "NA" after fix by recreating the factor
dating$flirted_online_cleaned<- factor(dating$flirted_online_cleaned)
summary(dating$flirted_online_cleaned)
#create dummy variables
contrasts(dating$flirted_online_cleaned)<-contr.treatment(2,base = 1)
levels(dating$flirted_online_cleaned)
summary(dating$flirted_online_cleaned)
dating$flirted_online_cleaned_recode <- ifelse(dating$flirted_online_cleaned=="Yes", 1, 0)
#t=table(dating$flirted_online_cleaned)
#D = data.frame( matrix(t,ncol=2))
#D$num.obs = D[,1]+D[,2]
#D$srate = D[,2]/D$num.obs
##check updated values
summary(dating$flirted_online_cleaned_recode)
##compute mean
mean(dating$flirted_online_cleaned_recode, na.rm=TRUE)
#compute odds for question 16. a
mean(dating$flirted_online_cleaned_recode, na.rm=TRUE)/(1-mean(dating$flirted_online_cleaned_recode, na.rm=TRUE))
#review usr variable
summary(dating$usr)
summary(dating$usr)
dating$usr_cleaned <- mapvalues(dating$usr, from = c(" "), to= c("NA"))
## NA is a string in dating$flirted_online_cleaned, recode to true NA
is.na(dating) <- dating=="NA"
# Can fix the remaining "NA" after fix by recreating the factor
dating$usr_cleaned<- factor(dating$usr_cleaned)
summary(dating$usr_cleaned)
# Only incorporate complete cases
#compute lim_rows logical vector for the 3 variables in question
lim_rows_glm = complete.cases(dating$flirted_online_cleaned_recode, dating$usr_cleaned)
## just the complete cases
dating_lim_glm = dating[lim_rows_glm,]
summary(dating_lim_glm$usr_cleaned)
#create dummy variables, make surburban base case
contrasts(dating$usr_cleaned)<-contr.treatment(3,base = 1)
dating$usr_cleaned
## Begin with a bivariate logistic regression given
model1 = glm(flirted_online_cleaned_recode ~ usr_cleaned, data=dating_lim_glm, family=binomial())
#grab AIC criterion
summary(model1)
exp(coef(model1))
attr(model1,"contrasts")
attr(usr_cleaned)
#create dummy variables, make surburban base case
contrasts(dating$usr_cleaned)<-contr.treatment(3,base = 2)
dating$usr_cleaned
#output odds, manually create odds ratio in answer
exp(coef(model1))
##odds ratio
2.1015464/0.1589404
summary(dating$usr_cleaned)
lim_rows_glm = complete.cases(dating$flirted_online_cleaned_recode, dating$usr_cleaned)
dating_lim_glm = dating[lim_rows_glm,]
summary(dating_lim_glm$usr_cleaned)
View(dating_lim_glm)
dating$usr_cleaned
